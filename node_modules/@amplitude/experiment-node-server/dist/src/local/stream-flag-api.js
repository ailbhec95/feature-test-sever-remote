"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkStreamFlagApi = void 0;
const stream_1 = require("../transport/stream");
const DEFAULT_INITIAL_CONN_TIMEOUT = 1000;
const DEFAULT_TRY_ATTEMPTS = 2;
const DEFAULT_TRY_WAIT_TIMEOUT = 1000;
/**
 * This class receives flag config updates from server.
 * It also handles errors, retries, flag parsing, and initial flags on connection, in addition to SdkStreamApi.
 */
class SdkStreamFlagApi {
    constructor(deploymentKey, serverUrl, eventSourceFactory, streamConnTimeoutMillis, streamFlagConnTimeoutMillis = DEFAULT_INITIAL_CONN_TIMEOUT, streamFlagTryAttempts = DEFAULT_TRY_ATTEMPTS, streamFlagTryDelayMillis = DEFAULT_TRY_WAIT_TIMEOUT) {
        // Flag for whether the stream is open and retrying or closed. This is to avoid calling connect() twice.
        this.isClosedAndNotTrying = true;
        this.api = new stream_1.SdkStream(deploymentKey, serverUrl + '/sdk/stream/v1/flags', eventSourceFactory, streamConnTimeoutMillis);
        this.streamFlagConnTimeoutMillis = Math.max(0, streamFlagConnTimeoutMillis);
        this.streamFlagTryAttempts = Math.max(1, streamFlagTryAttempts);
        this.streamFlagTryDelayMillis = Math.max(0, streamFlagTryDelayMillis);
    }
    // A try:
    // Try connect and receive at least one single flag update.
    connectTry(options) {
        // Timeout for initial connection. Makes sure the connection do not exceed a certain interval.
        let timeout = undefined;
        return new Promise((resolve, reject) => {
            // On connection and receiving first update, success, set future flag update callback and error handling retries.
            const dealWithFlagUpdateInOneTry = (data) => __awaiter(this, void 0, void 0, function* () {
                if (timeout) {
                    clearTimeout(timeout);
                }
                try {
                    // Make sure valid flag configs.
                    SdkStreamFlagApi.parseFlagConfigs(data);
                }
                catch (e) {
                    return reject(stream_1.DEFAULT_STREAM_ERR_EVENTS.DATA_UNPARSABLE);
                }
                // Update the callbacks.
                this.api.onUpdate = (data) => this.handleNewMsg(data, false);
                this.api.onError = (err) => this.errorAndRetry(err);
                // Handoff data to application. Make sure it finishes processing initial new flag configs.
                try {
                    yield this.handleNewMsg(data, true);
                    // Resolve promise which declares client ready.
                    resolve();
                }
                catch (_a) {
                    reject();
                }
            });
            this.api.onUpdate = dealWithFlagUpdateInOneTry;
            // If it fails to connect, fails try.
            // If it disconnects before flag update, fails try.
            const dealWithErrorInOneTry = (err) => __awaiter(this, void 0, void 0, function* () {
                if (timeout) {
                    clearTimeout(timeout);
                }
                reject(err); // Reject promise which will either retry or fatal err.
            });
            this.api.onError = dealWithErrorInOneTry;
            // Try connect.
            this.api.connect(options);
            // If it fails to return flag update within limit time, fails try.
            timeout = setTimeout(() => {
                dealWithErrorInOneTry(stream_1.DEFAULT_STREAM_ERR_EVENTS.TIMEOUT);
            }, this.streamFlagConnTimeoutMillis);
        });
    }
    // Do try up to 2 times. If any of error is fatal, stop any further tries.
    // If trials times reached, fatal error.
    connect(options) {
        return __awaiter(this, void 0, void 0, function* () {
            // Makes sure there is no other connect running.
            if (!this.isClosedAndNotTrying) {
                return;
            }
            this.isClosedAndNotTrying = false;
            this.options = options; // Save options for retries in case of errors.
            const attempts = this.streamFlagTryAttempts;
            const delay = this.streamFlagTryDelayMillis;
            for (let i = 0; i < attempts; i++) {
                try {
                    // Try.
                    return yield this.connectTry(options);
                }
                catch (e) {
                    if (this.isClosedAndNotTrying) {
                        // There's a call to close while waiting for connection.
                        return;
                    }
                    // connectTry() does not call close or closeForRetry on error.
                    const err = e;
                    if (this.isFatal(err) || i == attempts - 1) {
                        // We want to throw exception instead of call onError callback.
                        this.close();
                        throw err;
                    }
                    // Retry.
                    this.closeForRetry();
                    yield new Promise((resolve) => setTimeout(resolve, delay));
                    if (this.isClosedAndNotTrying) {
                        // There's a call to close while waiting for retry.
                        return;
                    }
                }
            }
        });
    }
    // Close stream.
    close() {
        this.closeForRetry();
        this.isClosedAndNotTrying = true;
    }
    // Close stream, but we know there will be another try happening very soon.
    closeForRetry() {
        this.api.close();
    }
    get isClosed() {
        return this.isClosedAndNotTrying;
    }
    // Fatal error if 501 Unimplemented.
    isFatal(err) {
        return err && (err === null || err === void 0 ? void 0 : err.status) == 501;
    }
    // If error during normal operation, retry init connection up to 2 times.
    errorAndRetry(err) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isFatal(err)) {
                this.close();
                yield this.fatalErr(err);
            }
            else {
                this.close(); // Not closeForRetry(), connect checks for isClosedAndNotTrying.
                this.connect(this.options).catch((err) => {
                    this.fatalErr(err);
                });
            }
        });
    }
    // No more retry, 501 unimplemented. Need fallback.
    fatalErr(err) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.onError) {
                try {
                    yield this.onError(err);
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { } // Don't care about application errors after handoff.
            }
        });
    }
    // Handles new messages, parse them, and handoff to application. Retries if have parsing error.
    handleNewMsg(data, isInit) {
        return __awaiter(this, void 0, void 0, function* () {
            let flagConfigs;
            try {
                flagConfigs = SdkStreamFlagApi.parseFlagConfigs(data);
            }
            catch (e) {
                this.errorAndRetry(stream_1.DEFAULT_STREAM_ERR_EVENTS.DATA_UNPARSABLE);
                return;
            }
            // Put update outside try catch. onUpdate error doesn't mean stream error.
            const updateFunc = isInit && this.onInitUpdate ? this.onInitUpdate : this.onUpdate;
            if (updateFunc) {
                try {
                    yield updateFunc(flagConfigs);
                }
                catch (e) {
                    // Only care about application errors after handoff if initing. Ensure init is success.
                    if (isInit) {
                        throw e;
                    }
                }
            }
        });
    }
    // Parse message. Throws if unparsable.
    static parseFlagConfigs(data) {
        const flagsArray = JSON.parse(data);
        return flagsArray.reduce((map, flag) => {
            map[flag.key] = flag;
            return map;
        }, {});
    }
}
exports.SdkStreamFlagApi = SdkStreamFlagApi;
