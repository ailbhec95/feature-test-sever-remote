"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CohortPoller = void 0;
const cohort_1 = require("../../util/cohort");
const logger_1 = require("../../util/logger");
class CohortPoller {
    constructor(fetcher, storage, flagCache, pollingIntervalMillis = 60000, debug = false) {
        this.fetcher = fetcher;
        this.storage = storage;
        this.flagCache = flagCache;
        this.pollingIntervalMillis = pollingIntervalMillis;
        this.logger = new logger_1.ConsoleLogger(debug);
    }
    /**
     * You must call this function to begin polling for cohort updates.
     *
     * Calling this function while the poller is already running does nothing.
     */
    start(onChange) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.poller) {
                this.logger.debug('[Experiment] cohort poller - start');
                this.poller = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield this.update(onChange);
                    }
                    catch (e) {
                        this.logger.debug('[Experiment] cohort update failed', e);
                    }
                }), this.pollingIntervalMillis);
            }
        });
    }
    /**
     * Stop polling for cohorts.
     *
     * Calling this function while the poller is not running will do nothing.
     */
    stop() {
        if (this.poller) {
            this.logger.debug('[Experiment] cohort poller - stop');
            clearTimeout(this.poller);
            this.poller = undefined;
        }
    }
    update(onChange) {
        return __awaiter(this, void 0, void 0, function* () {
            let changed = false;
            const promises = [];
            const cohortIds = cohort_1.CohortUtils.extractCohortIds(yield this.flagCache.getAll());
            for (const cohortId of cohortIds) {
                this.logger.debug(`[Experiment] updating cohort ${cohortId}`);
                // Get existing cohort and lastModified.
                const existingCohort = this.storage.getCohort(cohortId);
                let lastModified = undefined;
                if (existingCohort) {
                    lastModified = existingCohort.lastModified;
                }
                promises.push(this.fetcher
                    .fetch(cohortId, lastModified)
                    .then((cohort) => {
                    // Set.
                    if (cohort) {
                        this.storage.put(cohort);
                        changed = true;
                    }
                })
                    .catch((err) => {
                    this.logger.error('[Experiment] cohort poll failed', err);
                }));
            }
            yield Promise.all(promises);
            this.logger.debug(`[Experiment] cohort polled, changed: ${changed}`);
            if (onChange && changed) {
                yield onChange(this.storage);
            }
        });
    }
}
exports.CohortPoller = CohortPoller;
