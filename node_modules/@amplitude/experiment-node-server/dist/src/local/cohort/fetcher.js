"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CohortFetcher = exports.COHORT_CONFIG_TIMEOUT = void 0;
const version_1 = require("../../../gen/version");
const http_1 = require("../../transport/http");
const config_1 = require("../../types/config");
const logger_1 = require("../../util/logger");
const threading_1 = require("../../util/threading");
const time_1 = require("../../util/time");
const cohort_api_1 = require("./cohort-api");
exports.COHORT_CONFIG_TIMEOUT = 20000;
const ATTEMPTS = 3;
class CohortFetcher {
    constructor(apiKey, secretKey, httpClient, serverUrl = config_1.CohortSyncConfigDefaults.cohortServerUrl, maxCohortSize = config_1.CohortSyncConfigDefaults.maxCohortSize, cohortRequestDelayMillis = 100, debug = false) {
        this.inProgressCohorts = {};
        this.mutex = new threading_1.Mutex();
        this.executor = new threading_1.Executor(4);
        this.cohortApi = new cohort_api_1.SdkCohortApi(Buffer.from(apiKey + ':' + secretKey).toString('base64'), serverUrl, new http_1.WrapperClient(httpClient));
        this.maxCohortSize = maxCohortSize;
        this.cohortRequestDelayMillis = cohortRequestDelayMillis;
        this.logger = new logger_1.ConsoleLogger(debug);
    }
    static getKey(cohortId, lastModified) {
        return `${cohortId}_${lastModified ? lastModified : ''}`;
    }
    fetch(cohortId, lastModified) {
        return __awaiter(this, void 0, void 0, function* () {
            // This block may have async and awaits. No guarantee that executions are not interleaved.
            const unlock = yield this.mutex.lock();
            const key = CohortFetcher.getKey(cohortId, lastModified);
            if (!this.inProgressCohorts[key]) {
                this.inProgressCohorts[key] = this.executor.run(() => __awaiter(this, void 0, void 0, function* () {
                    this.logger.debug('Start downloading', cohortId);
                    for (let i = 0; i < ATTEMPTS; i++) {
                        try {
                            const cohort = yield this.cohortApi.getCohort({
                                libraryName: 'experiment-node-server',
                                libraryVersion: version_1.version,
                                cohortId: cohortId,
                                maxCohortSize: this.maxCohortSize,
                                lastModified: lastModified,
                                timeoutMillis: exports.COHORT_CONFIG_TIMEOUT,
                            });
                            // Do unlock before return.
                            const unlock = yield this.mutex.lock();
                            delete this.inProgressCohorts[key];
                            unlock();
                            this.logger.debug('Stop downloading', cohortId);
                            return cohort;
                        }
                        catch (e) {
                            if (i === ATTEMPTS - 1 ||
                                e instanceof cohort_api_1.CohortMaxSizeExceededError ||
                                e instanceof cohort_api_1.CohortClientRequestError) {
                                const unlock = yield this.mutex.lock();
                                delete this.inProgressCohorts[key];
                                unlock();
                                throw e;
                            }
                            yield (0, time_1.sleep)(this.cohortRequestDelayMillis);
                        }
                    }
                }));
            }
            const cohortPromise = this.inProgressCohorts[key];
            unlock();
            return cohortPromise;
        });
    }
}
exports.CohortFetcher = CohortFetcher;
