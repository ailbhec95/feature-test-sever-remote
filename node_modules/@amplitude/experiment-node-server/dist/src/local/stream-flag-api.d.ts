import { EvaluationFlag } from '@amplitude/experiment-core';
import { StreamEventSourceFactory, StreamOnErrorCallback, StreamOptions } from '../transport/stream';
export type StreamFlagOptions = StreamOptions;
export type StreamFlagOnUpdateCallback = (flags: Record<string, EvaluationFlag>) => unknown;
export type StreamFlagOnErrorCallback = StreamOnErrorCallback;
export interface StreamFlagApi {
    /**
     * To connect to the stream flag endpoint.
     * It will connect the stream and makes sure the initial flag configs are received and valid.
     * The initial flag configs are delivered through onUpdate.
     * It attempts to retry up to the attempts specified.
     * If fatal error happens during connect() call, error will be thrown instead of delivered through onError.
     * @param options Options for connection.
     */
    connect(options?: StreamOptions): Promise<void>;
    /**
     * To close the stream.
     * If application don't call this, the application may not exit as there are underlaying timers.
     */
    close(): void;
    /**
     * Check if the stream is closed and no retry action is happening.
     */
    isClosed: boolean;
    /**
     * Callback for receiving flag configs updates.
     * Can set this value directly multiple times and effect immediately.
     */
    onUpdate?: StreamFlagOnUpdateCallback;
    /**
     * Callback for receiving fatal errors.
     * Fatal errors are defined as server returning 501 or retry has reached max attempts.
     * This callback will not be called when error happens during connect() call. The error will be throwed in connect() instead.
     * Can set this value directly multiple times and effect immediately.
     */
    onError?: StreamFlagOnErrorCallback;
}
/**
 * This class receives flag config updates from server.
 * It also handles errors, retries, flag parsing, and initial flags on connection, in addition to SdkStreamApi.
 */
export declare class SdkStreamFlagApi implements StreamFlagApi {
    private api;
    private isClosedAndNotTrying;
    onInitUpdate?: StreamFlagOnUpdateCallback;
    onUpdate?: StreamFlagOnUpdateCallback;
    onError?: StreamFlagOnErrorCallback;
    private options?;
    private streamFlagConnTimeoutMillis;
    private streamFlagTryAttempts;
    private streamFlagTryDelayMillis;
    constructor(deploymentKey: string, serverUrl: string, eventSourceFactory: StreamEventSourceFactory, streamConnTimeoutMillis?: number, streamFlagConnTimeoutMillis?: number, streamFlagTryAttempts?: number, streamFlagTryDelayMillis?: number);
    private connectTry;
    connect(options?: StreamFlagOptions): Promise<void>;
    close(): void;
    private closeForRetry;
    get isClosed(): boolean;
    private isFatal;
    private errorAndRetry;
    private fatalErr;
    private handleNewMsg;
    private static parseFlagConfigs;
}
