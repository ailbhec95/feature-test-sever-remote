import { StreamEventSourceFactory } from '../transport/stream';
import { CohortStorage } from '../types/cohort';
import { FlagConfigCache } from '../types/flag';
import { CohortFetcher } from './cohort/fetcher';
import { FlagConfigPoller } from './poller';
import { FlagConfigUpdater, FlagConfigUpdaterBase } from './updater';
export declare class FlagConfigStreamer extends FlagConfigUpdaterBase implements FlagConfigUpdater {
    private readonly poller;
    private readonly stream;
    private readonly streamFlagRetryDelayMillis;
    private streamRetryInterval?;
    constructor(apiKey: string, poller: FlagConfigPoller, cache: FlagConfigCache, streamEventSourceFactory: StreamEventSourceFactory, streamFlagConnTimeoutMillis: number, streamFlagTryAttempts: number, streamFlagTryDelayMillis: number, streamFlagRetryDelayMillis: number, serverUrl: string, cohortStorage: CohortStorage, cohortFetcher?: CohortFetcher, debug?: boolean);
    /**
     * Fetch initial flag configurations and start polling for updates.
     *
     * You must call this function to begin polling for flag config updates.
     * The promise returned by this function is resolved when the initial call
     * to fetch the flag configuration completes.
     *
     * Calling this function while the poller is already running does nothing.
     */
    start(onChange?: (cache: FlagConfigCache) => Promise<void>): Promise<void>;
    /**
     * Stop polling for flag configurations.
     *
     * Calling this function while the poller is not running will do nothing.
     */
    stop(): void;
    /**
     * Force a flag config fetch and cache the update with an optional callback
     * which gets called if the flag configs change in any way.
     *
     * @param onChange optional callback which will get called if the flag configs
     * in the cache have changed.
     */
    update(onChange?: (cache: FlagConfigCache) => Promise<void>): Promise<void>;
    private startRetryStreamInterval;
    private clearRetryStreamInterval;
}
