"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlagConfigStreamer = void 0;
const version_1 = require("../../gen/version");
const config_1 = require("../types/config");
const stream_flag_api_1 = require("./stream-flag-api");
const updater_1 = require("./updater");
class FlagConfigStreamer extends updater_1.FlagConfigUpdaterBase {
    constructor(apiKey, poller, cache, streamEventSourceFactory, streamFlagConnTimeoutMillis = config_1.LocalEvaluationDefaults.streamFlagConnTimeoutMillis, streamFlagTryAttempts, streamFlagTryDelayMillis, streamFlagRetryDelayMillis, serverUrl = config_1.LocalEvaluationDefaults.serverUrl, cohortStorage, cohortFetcher, debug = false) {
        super(cache, cohortStorage, cohortFetcher, debug);
        this.logger.debug('[Experiment] streamer - init');
        this.poller = poller;
        this.stream = new stream_flag_api_1.SdkStreamFlagApi(apiKey, serverUrl, streamEventSourceFactory, streamFlagConnTimeoutMillis, streamFlagConnTimeoutMillis, streamFlagTryAttempts, streamFlagTryDelayMillis);
        this.streamFlagRetryDelayMillis = streamFlagRetryDelayMillis;
    }
    /**
     * Fetch initial flag configurations and start polling for updates.
     *
     * You must call this function to begin polling for flag config updates.
     * The promise returned by this function is resolved when the initial call
     * to fetch the flag configuration completes.
     *
     * Calling this function while the poller is already running does nothing.
     */
    start(onChange) {
        const _super = Object.create(null, {
            _update: { get: () => super._update }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.stream.onError = (e) => {
                const err = e;
                this.logger.debug(`[Experiment] streamer - onError, fallback to poller, err status: ${err === null || err === void 0 ? void 0 : err.status}, err message: ${err === null || err === void 0 ? void 0 : err.message}, err ${err}`);
                this.poller.start(onChange);
                this.startRetryStreamInterval();
            };
            this.stream.onInitUpdate = (flagConfigs) => __awaiter(this, void 0, void 0, function* () {
                this.logger.debug('[Experiment] streamer - receives updates');
                yield _super._update.call(this, flagConfigs, onChange);
                this.logger.debug('[Experiment] streamer - start flags stream success');
            });
            this.stream.onUpdate = (flagConfigs) => __awaiter(this, void 0, void 0, function* () {
                this.logger.debug('[Experiment] streamer - receives updates');
                yield _super._update.call(this, flagConfigs, onChange);
            });
            try {
                // Clear retry timeout. If stream isn't connected, we're trying now.
                // If stream is connected, timeout will be undefined and connect will do nothing.
                this.clearRetryStreamInterval();
                // stream connect error will be raised, not through calling onError.
                // So onError won't be called.
                // If close is called during connect, connect will return success. No sideeffects here.
                yield this.stream.connect({
                    libraryName: 'experiment-node-server',
                    libraryVersion: version_1.version,
                });
                this.poller.stop();
            }
            catch (e) {
                const err = e;
                this.logger.debug(`[Experiment] streamer - start stream failed, fallback to poller, err status: ${err === null || err === void 0 ? void 0 : err.status}, err message: ${err === null || err === void 0 ? void 0 : err.message}, err ${err}`);
                yield this.poller.start(onChange);
                this.startRetryStreamInterval();
            }
        });
    }
    /**
     * Stop polling for flag configurations.
     *
     * Calling this function while the poller is not running will do nothing.
     */
    stop() {
        this.logger.debug('[Experiment] streamer - stop');
        this.clearRetryStreamInterval();
        this.poller.stop();
        this.stream.close();
    }
    /**
     * Force a flag config fetch and cache the update with an optional callback
     * which gets called if the flag configs change in any way.
     *
     * @param onChange optional callback which will get called if the flag configs
     * in the cache have changed.
     */
    update(onChange) {
        return __awaiter(this, void 0, void 0, function* () {
            this.poller.update(onChange);
        });
    }
    // Retry stream after a while.
    startRetryStreamInterval() {
        this.clearRetryStreamInterval();
        this.streamRetryInterval = setInterval(() => {
            this.logger.debug('[Experiment] streamer - retry stream');
            this.stream
                .connect()
                .then(() => {
                this.logger.debug('[Experiment] streamer - retry stream success');
                // Clear interval.
                this.clearRetryStreamInterval();
                // Stop poller.
                this.poller.stop();
            })
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                .catch(() => { });
        }, this.streamFlagRetryDelayMillis);
    }
    // Clear retry interval.
    clearRetryStreamInterval() {
        if (this.streamRetryInterval) {
            clearInterval(this.streamRetryInterval);
            this.streamRetryInterval = undefined;
        }
    }
}
exports.FlagConfigStreamer = FlagConfigStreamer;
