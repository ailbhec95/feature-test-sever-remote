"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CohortUtils = void 0;
const experiment_core_1 = require("@amplitude/experiment-core");
const cohort_1 = require("../types/cohort");
class CohortUtils {
    static isCohortFilter(condition) {
        return ((condition.op == experiment_core_1.EvaluationOperator.SET_CONTAINS_ANY ||
            condition.op == experiment_core_1.EvaluationOperator.SET_DOES_NOT_CONTAIN_ANY) &&
            condition.selector.length != 0 &&
            condition.selector[condition.selector.length - 1] == 'cohort_ids');
    }
    static extractCohortIds(flagConfigs) {
        const cohortIdsByFlag = {};
        for (const key in flagConfigs) {
            cohortIdsByFlag[key] = CohortUtils.mergeAllValues(CohortUtils.extractCohortIdsByGroupFromFlag(flagConfigs[key]));
        }
        return CohortUtils.mergeAllValues(cohortIdsByFlag);
    }
    static extractCohortIdsByGroupFromFlag(flag) {
        const cohortIdsByGroup = {};
        if (flag.segments && Array.isArray(flag.segments)) {
            const segments = flag.segments;
            for (const segment of segments) {
                if (!segment || !segment.conditions) {
                    continue;
                }
                for (const outer of segment.conditions) {
                    for (const condition of outer) {
                        if (CohortUtils.isCohortFilter(condition)) {
                            // User cohort selector is [context, user, cohort_ids]
                            // Groups cohort selector is [context, groups, {group_type}, cohort_ids]
                            let groupType;
                            if (condition.selector.length > 2) {
                                if (condition.selector[1] == 'user') {
                                    groupType = cohort_1.USER_GROUP_TYPE;
                                }
                                else if (condition.selector.includes('groups')) {
                                    groupType = condition.selector[2];
                                }
                                else {
                                    continue;
                                }
                                if (!(groupType in cohortIdsByGroup)) {
                                    cohortIdsByGroup[groupType] = new Set();
                                }
                                condition.values.forEach(cohortIdsByGroup[groupType].add, cohortIdsByGroup[groupType]);
                            }
                        }
                    }
                }
            }
        }
        return cohortIdsByGroup;
    }
    static mergeValuesOfBIntoValuesOfA(a, b) {
        for (const groupType in b) {
            if (!(groupType in a)) {
                a[groupType] = new Set();
            }
            b[groupType].forEach(a[groupType].add, a[groupType]);
        }
    }
    static mergeAllValues(a) {
        const merged = new Set();
        for (const key in a) {
            a[key].forEach(merged.add, merged);
        }
        return merged;
    }
    static setSubtract(one, other) {
        const result = new Set();
        one.forEach((v) => {
            if (!other.has(v))
                result.add(v);
        });
        return result;
    }
}
exports.CohortUtils = CohortUtils;
