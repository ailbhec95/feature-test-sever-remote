export type StreamErrorEvent = {
    message?: string;
    status?: number;
};
export type StreamOpenEvent = {
    type?: string;
};
export type StreamMessageEvent = {
    data?: string;
};
export type StreamEvent = StreamErrorEvent | StreamOpenEvent | StreamMessageEvent;
/**
 * The EventSource client interface.
 * https://html.spec.whatwg.org/multipage/server-sent-events.html#eventsource
 */
export interface StreamEventSource {
    readonly CLOSED: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
    readonly url: string;
    readonly readyState: number;
    readonly withCredentials: boolean;
    onopen: (evt: StreamOpenEvent) => unknown;
    onmessage: (evt: StreamMessageEvent) => unknown;
    onerror: (evt: StreamErrorEvent) => unknown;
    close(): void;
}
export type StreamEventSourceFactory = (url: string, params: unknown) => StreamEventSource;
/**
 * Default error events.
 */
export declare const DEFAULT_STREAM_ERR_EVENTS: {
    TIMEOUT: StreamErrorEvent;
    DATA_UNPARSABLE: StreamErrorEvent;
    KEEP_ALIVE_FAILURE: StreamErrorEvent;
};
export type StreamOptions = {
    libraryName: string;
    libraryVersion: string;
};
export type StreamOnUpdateCallback = (data: string) => unknown;
export type StreamOnErrorCallback = (err: StreamErrorEvent) => unknown;
export interface Stream {
    /**
     * Initiate a connection. If an existing connection exists, it does nothing.
     */
    connect(options?: StreamOptions): void;
    /**
     * Close a connection. If there is no existing connection, it does nothing.
     */
    close(): void;
    /**
     * Any message will be sent to this callback.
     */
    onUpdate?: StreamOnUpdateCallback;
    /**
     * Any error, including connection errors, will be sent to this callback.
     */
    onError?: StreamOnErrorCallback;
}
/**
 * This class handles connecting to an server-side event source.
 * It handles keep alives from server, automatically disconnect and reconnect after a set random interval.
 * It will propagate any error to onError. It will not handle any error or retries.
 * (automatic disconnect does not count as error, but if any reconnect errors will propagate).
 */
export declare class SdkStream implements Stream {
    private eventSource;
    private reconnectionTimeout?;
    private initConnTimeout?;
    private keepAliveTimeout?;
    onUpdate?: StreamOnUpdateCallback;
    onError?: StreamOnErrorCallback;
    private readonly deploymentKey;
    private readonly serverUrl;
    private readonly eventSourceFactory;
    private streamConnTimeoutMillis;
    constructor(deploymentKey: string, serverUrl: string, eventSourceFactory: StreamEventSourceFactory, streamConnTimeoutMillis?: number);
    connect(options?: StreamOptions): Promise<void>;
    close(): void;
    private error;
    private handleNewMsg;
    private setKeepAliveExpiry;
}
