"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkStream = exports.DEFAULT_STREAM_ERR_EVENTS = void 0;
/**
 * Default error events.
 */
exports.DEFAULT_STREAM_ERR_EVENTS = {
    TIMEOUT: { message: 'timeout' },
    DATA_UNPARSABLE: {
        message: 'stream data parse error',
    },
    KEEP_ALIVE_FAILURE: {
        message: 'keep alive fail',
    },
};
const DEFAULT_INITIAL_CONN_TIMEOUT = 1000; // Initial connection timeout.
const MAX_CONN_MS_MIN = 12 * 60 * 1000; // Min of max connection timeout and wants to automatically disconnect and reconnects.
const MAX_CONN_MS_MAX = 18 * 60 * 1000; // Max of the above timeout.
const KEEP_ALIVE_INTERVAL = (15 + 2) * 1000; // 15 seconds plus 2 seconds grace period. // 0 or neg value disables keep alive.
const KEEP_ALIVE_DATA = ' ';
/**
 * This class handles connecting to an server-side event source.
 * It handles keep alives from server, automatically disconnect and reconnect after a set random interval.
 * It will propagate any error to onError. It will not handle any error or retries.
 * (automatic disconnect does not count as error, but if any reconnect errors will propagate).
 */
class SdkStream {
    constructor(deploymentKey, serverUrl, eventSourceFactory, streamConnTimeoutMillis = DEFAULT_INITIAL_CONN_TIMEOUT) {
        this.deploymentKey = deploymentKey;
        this.serverUrl = serverUrl;
        this.eventSourceFactory = eventSourceFactory;
        this.streamConnTimeoutMillis = streamConnTimeoutMillis;
    }
    connect(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.eventSource) {
                return;
            }
            const headers = {
                Authorization: `Api-Key ${this.deploymentKey}`,
            };
            if ((options === null || options === void 0 ? void 0 : options.libraryName) && (options === null || options === void 0 ? void 0 : options.libraryVersion)) {
                headers['X-Amp-Exp-Library'] = `${options.libraryName}/${options.libraryVersion}`;
            }
            // Create connection. It starts connection on new.
            const es = this.eventSourceFactory(this.serverUrl, {
                headers: headers,
            });
            this.eventSource = es; // Set eventSource here so more connect should only creates one eventSource.
            // Handlers.
            es.onerror = (err) => err && this.error(err);
            es.onmessage = (evt) => this.handleNewMsg(evt);
            es.onopen = (evt) => {
                if (!evt || !(evt === null || evt === void 0 ? void 0 : evt.type) || evt.type != 'open') {
                    return;
                }
                // Reconnect connections after certain amount of time.
                const randomReconnectionTimeout = Math.floor(Math.random() * (MAX_CONN_MS_MAX - MAX_CONN_MS_MIN) + MAX_CONN_MS_MIN);
                if (this.reconnectionTimeout) {
                    clearTimeout(this.reconnectionTimeout);
                }
                this.reconnectionTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    if (es.readyState == es.OPEN) {
                        // The es is being checked, not this.eventSource. So it won't affect new connections.
                        this.close();
                        this.connect();
                    }
                }), randomReconnectionTimeout);
                // Set keep alive checks.
                this.setKeepAliveExpiry();
            };
            // Timeout initial connection, ensures promise returns.
            // Force close after timeout only if stream is still connecting.
            // Error state should already handled by error handler.
            if (this.initConnTimeout) {
                clearTimeout(this.initConnTimeout);
            }
            this.initConnTimeout = setTimeout(() => {
                es.readyState == es.CONNECTING && // The es is being checked, not this.eventSource. So it won't affect new connections.
                    this.error(exports.DEFAULT_STREAM_ERR_EVENTS.TIMEOUT);
            }, this.streamConnTimeoutMillis);
        });
    }
    close() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = undefined;
        }
        // Clear timers so program won't hang if want to terminate early.
        if (this.initConnTimeout) {
            clearTimeout(this.initConnTimeout);
            this.initConnTimeout = undefined;
        }
        if (this.reconnectionTimeout) {
            clearTimeout(this.reconnectionTimeout);
            this.reconnectionTimeout = undefined;
        }
        if (this.keepAliveTimeout) {
            clearTimeout(this.keepAliveTimeout);
            this.keepAliveTimeout = undefined;
        }
    }
    error(err) {
        return __awaiter(this, void 0, void 0, function* () {
            this.close();
            if (this.onError) {
                try {
                    yield this.onError(err);
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { } // Don't care about errors after handoff.
            }
        });
    }
    handleNewMsg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!response.data) {
                return;
            }
            this.setKeepAliveExpiry(); // Reset keep alive as there is data.
            if (response.data == KEEP_ALIVE_DATA) {
                // Data solely for keep alive. Don't pass on to client.
                return;
            }
            if (this.onUpdate) {
                try {
                    yield this.onUpdate(response.data);
                    // eslint-disable-next-line no-empty
                }
                catch (_a) { } // Don't care about errors after handoff.
            }
        });
    }
    setKeepAliveExpiry() {
        if (this.keepAliveTimeout) {
            clearTimeout(this.keepAliveTimeout);
            this.keepAliveTimeout = undefined;
        }
        if (this.eventSource) {
            this.keepAliveTimeout = setTimeout(() => {
                this.error(exports.DEFAULT_STREAM_ERR_EVENTS.KEEP_ALIVE_FAILURE);
            }, KEEP_ALIVE_INTERVAL);
        }
    }
}
exports.SdkStream = SdkStream;
